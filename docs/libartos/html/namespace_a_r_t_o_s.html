<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ARTOS: ARTOS Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ARTOS
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Adaptive Real-Time Object Detection System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_a_r_t_o_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ARTOS Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_t_o_s_1_1_sample.html">Sample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_t_o_s_1_1_detection.html">Detection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_d_p_m_detection.html">DPMDetection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_image_repository.html">ImageRepository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_t_o_s_1_1_synset.html">Synset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_synset_image.html">SynsetImage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_synset_iterator.html">SynsetIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_image_iterator.html">ImageIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_synset_image_iterator.html">SynsetImageIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_mixed_image_iterator.html">MixedImageIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_t_o_s_1_1_tar_file_info.html">TarFileInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_tar_extractor.html">TarExtractor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_image_net_model_learner.html">ImageNetModelLearner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_model_evaluator.html">ModelEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_r_t_o_s_1_1_w_h_o_sample.html">WHOSample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_model_learner.html">ModelLearner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_random.html">Random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_r_t_o_s_1_1_stationary_background.html">StationaryBackground</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd37b5ade3218ab1d45852bc71bb0e52"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#abd37b5ade3218ab1d45852bc71bb0e52">ProgressCallback</a> )(unsigned int, unsigned int, void *)</td></tr>
<tr class="separator:abd37b5ade3218ab1d45852bc71bb0e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c14b83f7ca9c93807337a5b9250e5"><td class="memItemLeft" align="right" valign="top">typedef float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a032c14b83f7ca9c93807337a5b9250e5">hs_objective_function</a> )(const std::vector&lt; float &gt; &amp;, const std::vector&lt; int &gt; &amp;, void *)</td></tr>
<tr class="separator:a032c14b83f7ca9c93807337a5b9250e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7dad6285366859034dccdfa2761faa92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92">TarFileType</a> { <br/>
&#160;&#160;<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92a4864f042384075e244d2af9019f6aae0">tft_file</a>, 
<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92a91aeb66c0ab469bb067cb90e4ce2b660">tft_hard_link</a>, 
<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92aca7ff2c828a41ad8c934de56e59372e5">tft_symbolic_link</a>, 
<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92a7564bb860f47e32aae3ddc9d35484352">tft_character_special</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92a92fe3d3b493c3396b1294ab475005e3a">tft_block_special</a>, 
<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92a20e3f4af76faa95b6ed03e0d47ab2eb8">tft_directory</a>, 
<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92abfc66a84ae662b4bb2d75cda4ef07057">tft_fifo</a>, 
<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92afbc7e9d9d546cb549cfac6d663fb4136">tft_contiguous</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92ac94532c862444f39bfef76e7a3166242">tft_unknown</a>
<br/>
 }</td></tr>
<tr class="separator:a7dad6285366859034dccdfa2761faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9353cb7d44add44ac35800f4109cf929"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedCent &gt; </td></tr>
<tr class="memitem:a9353cb7d44add44ac35800f4109cf929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a9353cb7d44add44ac35800f4109cf929">kMeansClustering</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dataPoints, const unsigned int k, Eigen::VectorXi *assignments, Eigen::MatrixBase&lt; DerivedCent &gt; *centroids=NULL)</td></tr>
<tr class="separator:a9353cb7d44add44ac35800f4109cf929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13910115ab667592b26511453d72a9d2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedCent &gt; </td></tr>
<tr class="memitem:a13910115ab667592b26511453d72a9d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a13910115ab667592b26511453d72a9d2">repeatedKMeansClustering</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dataPoints, const unsigned int k, Eigen::VectorXi *assignments, Eigen::MatrixBase&lt; DerivedCent &gt; *centroids=NULL, const unsigned int numRuns=10)</td></tr>
<tr class="separator:a13910115ab667592b26511453d72a9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d256e698b1056a935847df6c69ac34"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a04d256e698b1056a935847df6c69ac34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a04d256e698b1056a935847df6c69ac34">mergeNearbyClusters</a> (Eigen::VectorXi &amp;assignments, Eigen::MatrixBase&lt; Derived &gt; &amp;centroids, const typename Derived::Scalar minDistance)</td></tr>
<tr class="separator:a04d256e698b1056a935847df6c69ac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3727c4158b447db97378256edd28b19e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a3727c4158b447db97378256edd28b19e">harmony_search</a> (<a class="el" href="namespace_a_r_t_o_s.html#a032c14b83f7ca9c93807337a5b9250e5">hs_objective_function</a> ofunc, const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;params, void *ofuncData=0, const bool maximize=false, float *bestFitness=0, const unsigned int hms=30, const unsigned int iterations=100000, const double hmcr=0.9, const double par=0.3)</td></tr>
<tr class="separator:a3727c4158b447db97378256edd28b19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb19f751e8c4b1e73d44a8167a8a23c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#abb19f751e8c4b1e73d44a8167a8a23c8">repeated_harmony_search</a> (<a class="el" href="namespace_a_r_t_o_s.html#a032c14b83f7ca9c93807337a5b9250e5">hs_objective_function</a> ofunc, const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;params, void *ofuncData=0, const bool maximize=false, float *bestFitness=0, const unsigned int hms=30, const unsigned int iterations=100000, const double hmcr=0.9, const double par=0.3)</td></tr>
<tr class="separator:abb19f751e8c4b1e73d44a8167a8a23c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62e4fc7921c6412b7b5f0ecec29ccd1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#ab62e4fc7921c6412b7b5f0ecec29ccd1">__attribute__</a> ((__packed__))</td></tr>
<tr class="separator:ab62e4fc7921c6412b7b5f0ecec29ccd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a55bf06c86afd8ca2262c6f2d34af10dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_a_r_t_o_s.html#a55bf06c86afd8ca2262c6f2d34af10dd">TarFileHeader</a></td></tr>
<tr class="separator:a55bf06c86afd8ca2262c6f2d34af10dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a032c14b83f7ca9c93807337a5b9250e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float(* ARTOS::hs_objective_function)(const std::vector&lt; float &gt; &amp;, const std::vector&lt; int &gt; &amp;, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd37b5ade3218ab1d45852bc71bb0e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ARTOS::ProgressCallback)(unsigned int, unsigned int, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a7dad6285366859034dccdfa2761faa92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_a_r_t_o_s.html#a7dad6285366859034dccdfa2761faa92">ARTOS::TarFileType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92a4864f042384075e244d2af9019f6aae0"></a>tft_file</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92a91aeb66c0ab469bb067cb90e4ce2b660"></a>tft_hard_link</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92aca7ff2c828a41ad8c934de56e59372e5"></a>tft_symbolic_link</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92a7564bb860f47e32aae3ddc9d35484352"></a>tft_character_special</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92a92fe3d3b493c3396b1294ab475005e3a"></a>tft_block_special</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92a20e3f4af76faa95b6ed03e0d47ab2eb8"></a>tft_directory</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92abfc66a84ae662b4bb2d75cda4ef07057"></a>tft_fifo</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92afbc7e9d9d546cb549cfac6d663fb4136"></a>tft_contiguous</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dad6285366859034dccdfa2761faa92ac94532c862444f39bfef76e7a3166242"></a>tft_unknown</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab62e4fc7921c6412b7b5f0ecec29ccd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARTOS::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(__packed__)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ASCII file header in tar archives. </p>
<p>&lt; null-terminated path name.</p>
<p>&lt; File mode, encoded as octal number string.</p>
<p>&lt; Numeric ID of the owner of the file, encoded as octal number string.</p>
<p>&lt; Numeric ID of the user group of the file, encoded as octal number string.</p>
<p>&lt; File size in bytes, encoded as octal number string.</p>
<p>&lt; Last modification time as UNIX timestamp, encoded as octal number string.</p>
<p>Flag indicating the type of the record. Possible values: '0'/NUL: normal file '1': hard link '2': symbolic link '3': character special '4': block special '5': directory '6': FIFO '7': contiguous file</p>
<p>&lt; Name of the linked file.</p>
<p>&lt; Contains "ustar" if this format is used.</p>
<p>&lt; User name of the owner of the file as null-terminated string.</p>
<p>&lt; Name of the group of the file as null-terminated string.</p>
<p>Prefix of filename if it is too long to fit in the first field. Split at any '/' character, that may have to be inserted between filename_prefix and filename.</p>

</div>
</div>
<a class="anchor" id="a3727c4158b447db97378256edd28b19e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ARTOS::harmony_search </td>
          <td>(</td>
          <td class="paramtype">hs_objective_function&#160;</td>
          <td class="paramname"><em>ofunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ofuncData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>maximize</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bestFitness</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hms</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>100000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>hmcr</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>par</em> = <code>0.3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the discrete <em>Harmony Search</em> algorithm to approximate the optimum of a multivariate objective function.</p>
<dl class="section see"><dt>See Also</dt><dd>Geem, Kim, Loganathan. A New Heuristic Optimization Algorithm: Harmony Search. In SIMULATION February 2001 76, pp. 60-68.</dd>
<dd>
<a href="http://en.wikipedia.org/wiki/Harmony_Search">http://en.wikipedia.org/wiki/Harmony_Search</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ofunc</td><td>A callback to the function to be optimized. It will be called with a vector of parameters as first argument and has to return a floating point value. A vector with the indices of the current parameters in the respective <code>params</code> vector is passed as second argument.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Vector of vectors with possible values for each parameter of the objective function. For example, if the function to be optimized had two parameters, this would be a vector of size 2; the first element would be a vector with all possible values of the first parameter of the function and the second element would be a vector with all possible values of the second parameter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ofuncData</td><td>Additional data to pass to the objective function <code>ofunc</code> as third argument.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximize</td><td>If this is set to true, the objective function will be maximized, otherwise minimized.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bestFitness</td><td>If set to a non-NULL value, the float variable pointed to will receive the value of the returned parameter combination according to the objective function.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hms</td><td><em>Harmony Memory Size</em>: The number of initially generated and stored parameter vectors.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>Harmony Search will terminate after exactly this number of rounds.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hmcr</td><td><em>Harmony Memory Considering Rate</em>: Probability to choose a new parameter from the <em>Harmony Memory</em> instead of selecting a random one.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">par</td><td><em>Pitch Adjusting Rate</em>: Probability to shift a parameter selected from <em>Harmony Memory</em> to one of it's neighbours. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9353cb7d44add44ac35800f4109cf929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename DerivedCent &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ARTOS::kMeansClustering </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dataPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi *&#160;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedCent &gt; *&#160;</td>
          <td class="paramname"><em>centroids</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies Lloyd's k-means clustering algorithm to a set of m n-dimensional data points, grouping them into exactly k clusters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataPoints</td><td>Eigen matrix with data points, one per row. So, for a total of m n-dimensional data points, this will be a m x n matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Number of clusters to form.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assignments</td><td>Pointer to an Eigen vector with m integral elements, which will receive information about the assignment of each data point to a cluster. So, if the i-th data point belongs to the j-th cluster, assignments(i) will be j. May be NULL.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroids</td><td>Pointer to an k x n matrix, which the computed centroids of each cluster will be written to, one per row. May be NULL. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_a_r_t_o_s_a9353cb7d44add44ac35800f4109cf929_cgraph.png" border="0" usemap="#namespace_a_r_t_o_s_a9353cb7d44add44ac35800f4109cf929_cgraph" alt=""/></div>
<map name="namespace_a_r_t_o_s_a9353cb7d44add44ac35800f4109cf929_cgraph" id="namespace_a_r_t_o_s_a9353cb7d44add44ac35800f4109cf929_cgraph">
<area shape="rect" id="node2" href="class_a_r_t_o_s_1_1_random.html#a55a61b6c2859deced8d0c5b690671abf" title="ARTOS::Random::seedOnce" alt="" coords="235,5,427,32"/><area shape="rect" id="node3" href="class_a_r_t_o_s_1_1_random.html#a0a5026c38579688e7ef13325a8676fe4" title="ARTOS::Random::getInt" alt="" coords="247,56,414,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a04d256e698b1056a935847df6c69ac34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ARTOS::mergeNearbyClusters </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar&#160;</td>
          <td class="paramname"><em>minDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modifies the results of a clustering operation, so that clusters whose centroids are close to each other will be merged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">assignments</td><td>Eigen vector of assignments of each data point to the cluster it belongs to, identified by the numerical ID of the cluster.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">centroids</td><td>The centroids of the clusters, one per row. Centroids of merged clusters will be re-calculated.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minDistance</td><td>The minimum distance between two clusters. Each pair of clusters whose distance is less than this value will be merged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb19f751e8c4b1e73d44a8167a8a23c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ARTOS::repeated_harmony_search </td>
          <td>(</td>
          <td class="paramtype">hs_objective_function&#160;</td>
          <td class="paramname"><em>ofunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ofuncData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>maximize</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bestFitness</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hms</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>100000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>hmcr</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>par</em> = <code>0.3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs the <a class="el" href="namespace_a_r_t_o_s.html#a3727c4158b447db97378256edd28b19e">harmony_search()</a> function multiple times at once in parallel threads and returns the best result of all runs.</p>
<p>If OpenMP is not enabled, this function is equivalent to <a class="el" href="namespace_a_r_t_o_s.html#a3727c4158b447db97378256edd28b19e">harmony_search()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespace_a_r_t_o_s.html#a3727c4158b447db97378256edd28b19e">harmony_search()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a13910115ab667592b26511453d72a9d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename DerivedCent &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ARTOS::repeatedKMeansClustering </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dataPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi *&#160;</td>
          <td class="paramname"><em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedCent &gt; *&#160;</td>
          <td class="paramname"><em>centroids</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numRuns</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs <a class="el" href="namespace_a_r_t_o_s.html#a9353cb7d44add44ac35800f4109cf929">kMeansClustering()</a> multiple times and returns the result with the least reconstruction error (i. e. the sum of the distances between the data points and their cluster's centroid).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataPoints</td><td>Eigen matrix with data points, one per row. So, for a total of m n-dimensional data points, this will be a m x n matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Number of clusters to form.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assignments</td><td>Pointer to an Eigen vector with m integral elements, which will receive information about the assignment of each data point to a cluster. So, if the i-th data point belongs to the j-th cluster, assignments(i) will be j. May be NULL.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centroids</td><td>Pointer to an k x n matrix, which the computed centroids of each cluster will be written to, one per row. May be NULL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRuns</td><td>Number of times to run clustering. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_a_r_t_o_s_a13910115ab667592b26511453d72a9d2_cgraph.png" border="0" usemap="#namespace_a_r_t_o_s_a13910115ab667592b26511453d72a9d2_cgraph" alt=""/></div>
<map name="namespace_a_r_t_o_s_a13910115ab667592b26511453d72a9d2_cgraph" id="namespace_a_r_t_o_s_a13910115ab667592b26511453d72a9d2_cgraph">
<area shape="rect" id="node2" href="namespace_a_r_t_o_s.html#a9353cb7d44add44ac35800f4109cf929" title="ARTOS::kMeansClustering" alt="" coords="288,31,469,57"/><area shape="rect" id="node3" href="class_a_r_t_o_s_1_1_random.html#a55a61b6c2859deced8d0c5b690671abf" title="ARTOS::Random::seedOnce" alt="" coords="517,5,709,32"/><area shape="rect" id="node4" href="class_a_r_t_o_s_1_1_random.html#a0a5026c38579688e7ef13325a8676fe4" title="ARTOS::Random::getInt" alt="" coords="530,56,697,83"/></map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a55bf06c86afd8ca2262c6f2d34af10dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARTOS::TarFileHeader</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_r_t_o_s.html">ARTOS</a></li>
    <li class="footer">Generated on Sun Jun 22 2014 18:57:09 for ARTOS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
